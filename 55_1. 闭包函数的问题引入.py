"""
1. 问题引入：
    a. 我们想计算一下比特币的平均收盘价
    b. 方法：建立一个空表，每次向空表里面添加一次收盘价，然后求这个表里面元素的平均值

list1 = []


def average(value):                 # 每次传入一个新的值，表示收盘价
    list1.append(value)             # 向空表中加入这个元素
    return sum(list1)/len(list1)    # 返回表中元素和的平均值


print(average(6000))  # 第一次的平均值  6000.0
print(average(7000))  # 第二次的平均值  6500.0
print(average(8000))  # 第三次的平均值  7000.0

# 存在的问题 定义的列表list是一个全局变量，容易被修改
# 于是我们想把列表放在函数中保护起来

"""

"""
2. 解决问题 当我们把列表放进函数中，又产生新的问题，函数执行完成后，所有的局部变量都会被释放，就没有了

def average(value):
    list1 = []
    list1.append(value)
    return sum(list1)/len(list1)  # 问题：当返回结果之后，所有的局部变量都将被释放

print(average(6000))  # 第一次的平均值  6000.0
print(average(7000))  # 第二次的平均值  7000.0
print(average(8000))  # 第三次的平均值  8000.0

"""

"""
3. 如何保存我们加入列表的值，于是产生闭包函数的写法
"""


def average():
    list1 = []                          # 1. 想要保存的变量，放在外层函数中，并且在内层函数中使用，这可以保证该变量不被释放

    def inner(value):
        list1.append(value)
        return sum(list1)/len(list1)
    return inner                        # 2. 外层函数返回的是内层函数的接口


avg = average()
# 相当于说函数的返回值用一个变量来接收，二这个返回值是inner函数
# 于是相当于这个变量指向inne函数，因此传入的参数是inner函数需要的参数


"""
注意：
1. 闭包函数中的自由变量是通过函数对象的一个内部成员变量来保存的，这个成员变量被称为“闭包”或“自由变量环境”。

2. 当一个函数定义在另一个函数的内部时，它可以访问其父函数中的变量。如果这个内部函数在外部被调用，它可以捕获并保持对其父函数中的变量的引用，
这些变量被称为“自由变量”。这个过程被称为“闭包”。

3. 在执行过程中，当父函数执行完毕后，其局部变量会被销毁，但是由于闭包函数中的自由变量环境中仍然保留了对这些变量的引用，
因此这些变量不会被销毁。这就允许闭包函数在后续的调用中仍然能够访问并修改这些变量的值。

"""

print(avg(6000))  # 6000.0
print(avg(7000))  # 6500.0
print(avg(8000))  # 7000.0




















